# Классификация уровня IT-специалистов

Этот проект — **Proof of Concept (PoC)** для задачи автоматического определения грейда IT-специалиста (**Junior / Middle / Senior**) на основе данных из резюме (датасет hh.ru).

## Цель проекта

Проверить гипотезу: можно ли по косвенным признакам (зарплата, возраст, город, образование, тип занятости и др.) предсказать уровень квалификации, **не используя** при обучении те признаки, по которым производилась разметка (название должности и стаж работы), чтобы избежать утечки целевой переменной.

## Результаты

### Статистика обработки данных

- **Исходный датасет**: 66,945 резюме
- **Отфильтровано IT-специалистов**: 30,184 (45.1%)
- **Обучающая выборка**: 24,147 резюме (80%)
- **Тестовая выборка**: 6,037 резюме (20%)

### Распределение классов

| Уровень | Количество | Процент |
|---------|------------|---------|
| **Senior** | 20,296 | 67.2% |
| **Middle** | 6,218 | 20.6% |
| **Junior** | 3,670 | 12.2% |

**Примечание**: Наблюдается значительный дисбаланс классов — Senior разработчики составляют более двух третей выборки.

### Метрики качества модели

| Метрика | Значение | Комментарий |
|---------|----------|-------------|
| **Accuracy** | **0.75** | Модель верно определяет грейд в 75% случаев |
| **F1 (Senior)** | **0.86** | Сеньоры определяются очень точно (precision: 0.91, recall: 0.83) |
| **F1 (Junior)** | **0.56** | Джуны часто путаются с Мидлами (precision: 0.52, recall: 0.61) |
| **F1 (Middle)** | **0.56** | Мидлы — самый сложный для разделения класс (precision: 0.51, recall: 0.61) |
| **Macro avg F1** | **0.66** | Среднее F1 по всем классам |
| **Weighted avg F1** | **0.76** | Взвешенное среднее F1 (учитывает дисбаланс) |

### Ключевые факторы (Top Features)

| Ранг | Признак | Важность (%) | Описание |
|------|---------|--------------|----------|
| 1 | **age** | **36.08** | Возраст — сильнейший косвенный признак опыта |
| 2 | **salary_rub** | **17.60** | Зарплата — четко коррелирует с уровнем ответственности |
| 3 | **birth_month** | **9.84** | Месяц рождения — вероятно, шумовой признак или артефакт данных |
| 4 | **has_car** | **4.98** | Наличие авто — косвенный признак дохода/возраста |
| 5 | **employment_internship** | **3.06** | Стажировка — индикатор Junior уровня |
| 6 | **region_Moscow & Oblast** | **2.93** | Регион Москвы — влияет на уровень зарплат и требований |
| 7 | **schedule_shift** | **2.48** | Сменный график — может коррелировать с опытом |
| 8 | **schedule_remote** | **1.95** | Удаленная работа — популярна среди опытных специалистов |

**Всего извлечено признаков**: 31 (после one-hot кодирования категориальных признаков)

## Архитектура проекта

Пайплайн обработки данных построен на паттерне **Pipeline со стадиями (Stages)**. Данные проходят через последовательность стадий обработки, каждая из которых выполняет свою задачу:

### Структура пайплайна

1. **Загрузка данных**: Чтение CSV файла в память
2. **Фильтрация**: Отбор только IT-специалистов (по ключевым словам `developer`, `qa`, `devops`, `python` и др.)
3. **Извлечение признаков**: 
   - Персональная информация (пол, возраст, месяц рождения)
   - Зарплата (нормализованная в рублях)
   - Опыт работы (в месяцах)
4. **Разметка (Labeling)**:
   - Грейд проставляется на основе **названия должности** (ключевые слова `senior`, `junior`, `lead`) и **опыта работы** (пороги < 1.5 года / 1.5–5 лет / > 5 лет)
   - **Важно:** Сразу после разметки столбцы `название должности`, `опыт работы` и `предыдущая должность` **удаляются** из датасета. Модель их не видит
5. **Дополнительные признаки**:
   - Город (категоризация по регионам)
   - Тип занятости (полная/частичная, проектная работа и т.д.)
   - График работы (полный день, удаленно, гибкий график)
   - Образование (высшее, среднее специальное и т.д.)
   - Прочие (наличие авто, возраст резюме)
6. **Кодирование**: Категориальные признаки кодируются (One-Hot Encoding)
7. **Разделение**: Данные разделяются на матрицу признаков и вектор целевой переменной

### Обучение модели

Обучается градиентный бустинг **CatBoostClassifier**:
- 300 итераций
- `auto_class_weights='Balanced'` для учета дисбаланса классов
- Глубина деревьев: 6
- Learning rate: 0.1

## Структура проекта

```
HW_05/
├── src/
│   ├── core.py                    # Базовые классы (DataContainer, DataStage, ProcessingPipeline)
│   └── transformations/           # Модули трансформаций данных
│       ├── data_loader.py         # Загрузка CSV
│       ├── filters.py             # Фильтр IT-вакансий
│       ├── feature_extractors.py  # Извлечение признаков (возраст, зарплата, город...)
│       ├── labeling.py            # Логика разметки Junior/Middle/Senior
│       └── preprocessing.py       # Кодирование признаков и разделение данных
├── main.py                        # Основной скрипт запуска (pipeline + обучение + отчет)
├── grade_distribution.png         # График распределения классов
├── classification_report.txt      # Детальный отчет о метриках
└── README.md                      # Этот файл
```

## Запуск

### Требования

- Python 3.9+
- Установленные зависимости:
  - `catboost`
  - `scikit-learn`
  - `pandas`
  - `numpy`
  - `matplotlib`
  - `seaborn`

### Установка зависимостей

Установите зависимости из файла `requirements.txt`:

```bash
pip install -r requirements.txt
```

Или установите вручную:

```bash
pip install catboost scikit-learn pandas numpy matplotlib seaborn
```

### Запуск скрипта

1. Убедитесь, что файл `hh.csv` находится в корне проекта или в одном из стандартных мест:
   - `hh.csv`
   - `parsing/hh.csv`
   - `../parsing/hh.csv`

2. Запустите основной скрипт:
   ```bash
   python main.py
   ```

Скрипт автоматически:
- Найдет `hh.csv`
- Проведет очистку и разметку данных
- Обучит модель
- Сохранит график распределения (`grade_distribution.png`) и отчет (`classification_report.txt`)

## Выводы

Proof of Concept показал, что **автоматическая классификация грейда возможна** даже без прямых данных об опыте работы и названии должности.

### Основные выводы

1. **Гипотеза подтверждена**: По косвенным признакам резюме можно восстановить квалификацию специалиста с разумной точностью (75%), что достаточно для задач первичного скрининга или аналитики рынка.

2. **Senior разработчики определяются лучше всего**:
   - Precision: 0.91 (91% предсказанных Senior действительно Senior)
   - Recall: 0.83 (83% всех Senior правильно определены)
   - F1-score: 0.86
   - Это связано с тем, что Senior класс самый многочисленный и имеет более выраженные характеристики

3. **Junior и Middle сложно разделить**:
   - Оба класса имеют F1-score 0.56
   - Precision для обоих классов около 0.51-0.52
   - Это указывает на то, что косвенные признаки (возраст, образование, город) у них часто пересекаются

4. **Возраст — самый важный признак** (36% важности):
   - Сильно коррелирует с опытом работы
   - Позволяет косвенно оценить уровень специалиста

5. **Зарплата — второй по важности признак** (17.6%):
   - Четко отражает уровень ответственности и квалификации
   - Senior разработчики обычно имеют более высокие зарплатные ожидания

### Рекомендации для улучшения

1. **Балансировка классов**: Использовать техники oversampling/undersampling или более агрессивные веса классов
2. **Улучшение разметки**: Ручная проверка и корректировка разметки для пограничных случаев
3. **Удаление шумовых признаков**: Исключить признаки, не несущие реальной информации (месяц рождения)
4. **Дополнительные признаки**: Извлечь больше информации из текста резюме (навыки, технологии, проекты)
5. **Ансамбли моделей**: Комбинировать несколько моделей для улучшения качества предсказаний
